##### 导入库###########
library("devtools")
if(exists("cfcausal:::summary_CI")){
  rm(list = c("summary_CI"))
}
devtools::load_all(".")
library("cfcausal")
library("dplyr")
library("ggplot2")
library("bannerCommenter")
library("readxl")
options(scipen=999)

##### 获取参数 #######
suppressPackageStartupMessages(library("argparse"))
parser <- ArgumentParser()
parser$add_argument("--gmm_star", type = "double", default = 3, help = "SA parameter, >=1")
parser$add_argument("--alpha", type="double", default=0.2, help="miscoverage")
parser$add_argument("--save", type="logical", default=TRUE, help="save")
parser$add_argument("--seed", type = "double", default = 1, help = "random seed")
parser$add_argument("--ntrial", type = "integer", default = 5, help = "number of trials")
parser$add_argument("--path", type = "character", default = './results/residual/', help = "save location")
args <- parser$parse_args()
alpha <- args$alpha
gmm_star <- args$gmm_star
ntrial<- args$ntrial
seed <- args$seed
save <- args$save
path = args$path
q<- c(alpha/2, 1- (alpha/2))
dir.create(path, recursive=TRUE, showWarnings = FALSE)


##### 绘制残差分布箱线图 ##########
outlier_detect <- function(vec){
  # 计算分位数和IQR
  Q1 <- quantile(vec, 0.25)
  Q3 <- quantile(vec, 0.75)
  IQR <- Q3 - Q1

  # 计算上限和下限值
  upper <- Q3 + 1.5 * IQR
  lower <- Q1 - 1.5 * IQR

  # 计算离群值的数量
  outliers <- vec[vec < lower | vec > upper]
  num_outliers <- length(outliers)

  # 计算离群值的百分比
  percent_outliers <- (num_outliers / length(vec)) * 100

  print(paste("离群值的数量：", num_outliers))
  print(paste("离群值的百分比：", percent_outliers, "%"))

  return(num_outliers)
}

plot_residual <- function(dataset, Y_all, X1, A){
  n<- length(Y_all)
  trainprop <- 0.8
  set.seed(123)
  trainid <- sample(n, floor(n * trainprop))
  set.seed(NULL)

  # 训练集数据的划分
  Y_obs <- Y_all[trainid]
  X <- X1[trainid,]
  T_obs <- A[trainid]

  Y1 <- Y_obs
  Y1[which(T_obs==0)] <- NA

  Y0 <- Y_obs
  Y0[which(T_obs==1)] <- NA

  id <- seq(1, n)
  testid<- id[!(id %in% trainid)]
  Xtest <- X1[testid,]

  # 训练模型并获取残差
  Xtrain.1 <- X[T_obs==1,]
  Ytrain.1 <- Y1[T_obs==1]
  Ymodel.1 <- function(X){ #31
    outparams <- c(list(Y = Ytrain.1, X = Xtrain.1, quantiles = list()), outparams = list())
    do.call("RF", c(outparams, list(Xtest = X)))
  }
  residual.1 <- Ytrain.1 - Ymodel.1(Xtrain.1)
  out.1 <- outlier_detect(residual.1)

  Xtrain.0 <- X[T_obs==0,]
  Ytrain.0 <- Y0[T_obs==0]
  Ymodel.0 <- function(X){ #33
    outparams <- c(list(Y = Ytrain.0, X = Xtrain.0, quantiles = list()), outparams = list())
    do.call("RF", c(outparams, list(Xtest = X)))
  }
  residual.0 <- Ytrain.0 - Ymodel.0(Xtrain.0)
  out.0 <- outlier_detect(residual.0)

  # 绘制残差箱线图并保存
  folder<- paste0(path, dataset,"_box.png")
  png(folder)
  par(mfrow=c(1,2))
  boxplot(residual.1, col = 'yellow', main = "residual of t = 1")
  boxplot(residual.0, col = 'pink', main = "residual of t = 0")
  par(mfrow=c(1,1))
  dev.off()

  print((out.0+out.1)/(n * trainprop))
}

##### VK #####
# 导入数据
# 读取vk.csv
vk <- read.csv("data/VK2.csv")
vk$Gender <- ifelse(vk$Gender  == "Male", 1, 0)
vk$Access <- ifelse(vk$Access  == "AVFistula", 1, 0)
# 使用ifelse函数，把"Yes"替换为1，把"No"替换为0
# 将需要变成0-1变量的列进行转换
# 生成模型矩阵并赋值给mm
mm <- model.matrix(~ HTN + DM + HCV + Smoking + Heartfailure + ISHD, data = vk)
# 把mm数据框中的虚拟编码替换到vk数据框中
# 创建一个向量col_names，存储mm数据框中除了截距项之外的列名
col_names <- colnames(mm)[-1]
# 使用for循环遍历col_names向量中的每个元素
for (col in col_names) {
  # 使用赋值符号<-把mm数据框中对应列的值覆盖到vk数据框中对应列上
  vk[, col] <- mm[, col]
}
# 筛选处理组和控制组
A <- as.numeric(vk$T == 1)
# 定义协变量矩阵
X <- vk[, c("Gender","HTNYes","DMYes" , "HCVYes","SmokingYes", "HeartfailureYes" ,"ISHDYes","Access","Age","Durationofdialysis", "PTH", "Ca.Pre","PHPre", "CaxPProductPre","MGPPre")]
X1 <- model.matrix(~ . - 1, X)
# 定义响应变量
Y_all <- vk$MGPPost
plot_residual("VK", Y_all, X1, A)
outlier_detect(vk$MGPPost)
outlier_detect(log2(vk$MGPPost))

##### VD ######
vd <- read.csv("data/VD.csv")
# 筛选处理组和控制组
A <- as.numeric(vd$Group == "A")
# 定义协变量矩阵
X <- vd[, c("Sex", "Age",
            "Height", "BW", #"BMI",
            "FIB4","APRI","VD0","AST0","ALT0","Plt0","TGF0",
            "TIMP0","MMP0","P3NP0")]
X[X$Sex == 2,]$Sex <- 0
X1 <- model.matrix(~ . - 1, X)
# 定义响应变量
Y_all <- vd$TGF6
plot_residual("VD", Y_all, X1, A)
outlier_detect(vd$TGF6)
outlier_detect(log2(vd$TGF6))






